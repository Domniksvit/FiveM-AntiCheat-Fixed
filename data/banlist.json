[  
TAC                     = {Locales = {}

function _(str, ...)
    local config = Config or {}
    local locale = config.Locale or 'en'

	if Locales[locale] ~= nil then

		if Locales[locale][str] ~= nil then
			return string.format(Locales[locale][str], ...)
		else
			return 'Translation [' .. locale .. '][' .. str .. '] does not exist'
		end

	else
		return 'Locale [' .. locale .. '] does not exist'
	end

end

function _U(str, ...)
	return tostring(_(str, ...):gsub("^%l", string.upper))
end}
TAC.CurrentRequestId    = 0
TAC.ServerCallbacks     = {}
TAC.ClientCallbacks     = {}
TAC.ClientEvents        = {}
TAC.Config              = {}
TAC.SecurityTokens      = {}

TAC.RegisterClientCallback = function(name, cb)
    TAC.ClientCallbacks[name] = cb
end

TAC.RegisterClientEvent = function(name, cb)
    TAC.ClientEvents[name] = cb
end

TAC.TriggerServerCallback = function(name, cb, ...)
    TAC.ServerCallbacks[TAC.CurrentRequestId] = cb

    local token = TAC.GetResourceToken(GetCurrentResourceName())

    TriggerServerEvent('tigoanticheat:triggerServerCallback', name, TAC.CurrentRequestId, token, ...)

    if (TAC.CurrentRequestId < 65535) then
        TAC.CurrentRequestId = TAC.CurrentRequestId + 1
    else
        TAC.CurrentRequestId = 0
    end
end

TAC.TriggerServerEvent = function(name, ...)
    local token = TAC.GetResourceToken(GetCurrentResourceName())

    TriggerServerEvent('tigoanticheat:triggerServerEvent', name, token, ...)
end

TAC.TriggerClientCallback = function(name, cb, ...)
    if (TAC.ClientCallbacks ~= nil and TAC.ClientCallbacks[name] ~= nil) then
        TAC.ClientCallbacks[name](cb, ...)
    end
end

TAC.TriggerClientEvent = function(name, ...)
    if (TAC.ClientEvents ~= nil and TAC.ClientEvents[name] ~= nil) then
        TAC.ClientEvents[name](...)
    end
end

TAC.ShowNotification = function(msg)
    AddTextEntry('tacNotification', msg)
	SetNotificationTextEntry('tacNotification')
	DrawNotification(false, true)
end

TAC.RequestAndDelete = function(object, detach)
    if (DoesEntityExist(object)) then
        NetworkRequestControlOfEntity(object)

        while not NetworkHasControlOfEntity(object) do
            Citizen.Wait(0)
        end

        if (detach) then
            DetachEntity(object, 0, false)
        end

        SetEntityCollision(object, false, false)
        SetEntityAlpha(object, 0.0, true)
        SetEntityAsMissionEntity(object, true, true)
        SetEntityAsNoLongerNeeded(object)
        DeleteEntity(object)
    end
end

RegisterNetEvent('tigoanticheat:serverCallback')
AddEventHandler('tigoanticheat:serverCallback', function(requestId, ...)
	if (TAC.ServerCallbacks ~= nil and TAC.ServerCallbacks[requestId] ~= nil) then
		TAC.ServerCallbacks[requestId](...)
        TAC.ServerCallbacks[requestId] = nil
	end
end)]TAC.LoadWhitelistedIPs = function()
    local ipsContent = LoadResourceFile(GetCurrentResourceName(), 'data/ignore-ips.json')

    if (not ipsContent) then
        local newIPList = json.encode({})

        ipsContent = newIPList

        SaveResourceFile(GetCurrentResourceName(), 'data/ignore-ips.json', newIPList, -1)
    end

    local whitelistedIPs = json.decode(ipsContent)

    if (not whitelistedIPs) then
        print('-------------------!' .. _('fatal_error') .. '!------------------\n')
        print(_('failed_to_load_ips') .. '\n')
        print(_('failed_to_load_check') .. '\n')
        print('-------------------!' .. _('fatal_error') .. '!------------------\n')

        TAC.WhitelistedIPs = {}
    else
        TAC.WhitelistedIPs = whitelistedIPs
    end

    TAC.WhitelistedIPsLoaded = true
end

TAC.AddIPToWhitelist = function(ip)
    if (not TAC.ValidIP(ip)) then
        return false
    end

    local ipAlreadyAdded = false

    for _, _ip in pairs(TAC.WhitelistedIPs) do
        if (_ip == ip) then
            ipAlreadyAdded = true
        end
    end

    if (ipAlreadyAdded) then
        return true
    end

    table.insert(TAC.WhitelistedIPs, ip)

    TAC.SaveWhitelistedIPs()

    return true
end

TAC.SaveWhitelistedIPs = function()
    SaveResourceFile(GetCurrentResourceName(), 'data/ignore-ips.json', json.encode(TAC.WhitelistedIPs or {}, { indent = true }), -1)
end

TAC.GetPlayerIP = function(playerId)
    local identifiers = GetPlayerIdentifiers(playerId)
    local ip = nil

    for _, identifier in pairs(identifiers) do
        if (string.match(string.lower(identifier), 'ip:')) then
            ip = string.sub(identifier, 4)
        end
    end

    return ip
end

TAC.ValidIP = function(ip)
    if ip == nil or type(ip) ~= "string" then
        return false
    end

    local chunks = {ip:match("(%d+)%.(%d+)%.(%d+)%.(%d+)")}

    if (#chunks == 4) then
        for _,v in pairs(chunks) do
            if (tonumber(v) < 0 or tonumber(v) > 255) then
                return false
            end
        end
        return true
    else
        return false
    end

    return false
end     
   TAC.LoadSecurityTokens = function()
    local tokenContent = LoadResourceFile(GetCurrentResourceName(), 'data/token.json')

    if (not tokenContent) then
        local newTokenList = json.encode({})

        tokenContent = newTokenList

        SaveResourceFile(GetCurrentResourceName(), 'data/token.json', newTokenList, -1)
    end

    local storedTokens = json.decode(tokenContent)

    if (not storedTokens) then
        print('-------------------!' .. _('fatal_error') .. '!------------------\n')
        print(_('failed_to_load_tokenlist') .. '\n')
        print(_('failed_to_load_check') .. '\n')
        print('-------------------!' .. _('fatal_error') .. '!------------------\n')

        TAC.SecurityTokens = {}
    else
        TAC.SecurityTokens = storedTokens
    end

    TAC.SecurityTokensLoaded = true
end

TAC.SaveSecurityTokens = function()
    SaveResourceFile(GetCurrentResourceName(), 'data/token.json', json.encode(TAC.SecurityTokens or {}, { indent = true }), -1)
end

TAC.GetSteamIdentifier = function(source)
    if (source == nil) then
        return ''
    end

    local playerId = tonumber(source)

    if (playerId <= 0) then
        return ''
    end

    local identifiers, steamIdentifier = GetPlayerIdentifiers(source)

    for _, identifier in pairs(identifiers) do
        if (string.match(string.lower(identifier), 'steam:')) then
            steamIdentifier = identifier
        end
    end

    return steamIdentifier
end

TAC.GetClientSecurityToken = function(source, resource)
    if (TAC.SecurityTokens ~= nil and TAC.SecurityTokens[tostring(source)] ~= nil) then
        local steamIdentifier = TAC.GetSteamIdentifier(source)

        for _, resourceToken in pairs(TAC.SecurityTokens[tostring(source)]) do
            if (resourceToken.name == resource and resourceToken.steam == steamIdentifier) then
                return resourceToken
            elseif (resourceToken.name == resource) then
                table.remove(TAC.SecurityTokens[tostring(source)], _)
            end
        end
    end

    return nil
end

TAC.GenerateSecurityToken = function(source, resource)
    local currentToken = TAC.GetClientSecurityToken(source, resource)

    if (currentToken == nil) then
        local newResourceToken = {
            name = resource,
            token = TAC.RandomString(Config.TokenLength),
            time = os.time(),
            steam = TAC.GetSteamIdentifier(source),
            shared = false
        }

        if (TAC.SecurityTokens == nil) then
            TAC.SecurityTokens = {}
        end

        if (TAC.SecurityTokens[tostring(source)] == nil) then
            TAC.SecurityTokens[tostring(source)] = {}
        end

        table.insert(TAC.SecurityTokens[tostring(source)], newResourceToken)

        TAC.SaveSecurityTokens()

        return newResourceToken
    end

    return nil
end

TAC.GetCurrentSecurityToken = function(source, resource)
    local currentToken = TAC.GetClientSecurityToken(source, resource)

    if (currentToken == nil) then
        local newToken = TAC.GenerateSecurityToken(source, resource)

        if (not newToken.shared) then
            TAC.TriggerClientEvent(source, 'tigoanticheat:storeSecurityToken', newToken)
        end

        if (newToken == nil) then
            TAC.KickPlayerWithReason(source, _U('kick_type_security_token'))
            return nil
        else
            return newToken
        end
    end

    return currentToken
end

TAC.ValidateToken = function(source, resource, token)
    local currentToken = TAC.GetCurrentSecurityToken(source, resource)

    if (currentToken == nil and token == nil) then
        return true
    elseif(currentToken ~= nil and not currentToken.shared and token == nil) then
        return true
    elseif(currentToken ~= nil and currentToken.token == token) then
        return true
    end

    return false
end

TAC.ValidateOrKick = function(source, resource, token)
    if (not TAC.ValidateToken(source, resource, token)) then
        TAC.KickPlayerWithReason(_U('kick_type_security_mismatch'))
        return false
    end

    return true
end

TAC.RegisterServerEvent('tigoanticheat:storeSecurityToken', function(source, resource)
    if (TAC.SecurityTokens ~= nil and TAC.SecurityTokens[tostring(source)] ~= nil) then
        local steamIdentifier = TAC.GetSteamIdentifier(source)

        for _, resourceToken in pairs(TAC.SecurityTokens[tostring(source)]) do
            if (resourceToken.name == resource and resourceToken.steam == steamIdentifier) then
                resourceToken.shared = true
                TAC.SecurityTokens[tostring(source)][_].shared = true
            elseif (resourceToken.name == resource) then
                table.remove(TAC.SecurityTokens[tostring(source)], _)
            end
        end

        TAC.SaveSecurityTokens()
    end
end)
